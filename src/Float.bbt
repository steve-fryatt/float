REM >!Float
REM
REM Copyright 1999-2014, Stephen Fryatt (info@stevefryatt.org.uk)
REM
REM This file is part of Float:
REM
REM   http://www.stevefryatt.org.uk/software/
REM
REM Licensed under the EUPL, Version 1.1 only (the "Licence");
REM You may not use this work except in compliance with the
REM Licence.
REM
REM You may obtain a copy of the Licence at:
REM
REM   http://joinup.ec.europa.eu/software/page/eupl
REM
REM Unless required by applicable law or agreed to in
REM writing, software distributed under the Licence is
REM distributed on an "AS IS" basis, WITHOUT WARRANTIES
REM OR CONDITIONS OF ANY KIND, either express or implied.
REM
REM See the Licence for the specific language governing
REM permissions and limitations under the Licence.

LIBRARY "BASIC:Config"
LIBRARY "BASIC:Icon"
LIBRARY "BASIC:Menu"
LIBRARY "BASIC:Resources"
LIBRARY "BASIC:String"
LIBRARY "BASIC:Template"
LIBRARY "BASIC:Url"
LIBRARY "BASIC:WimpError"
LIBRARY "BASIC:WimpSprite"
LIBRARY "BASIC:Window"

LIBRARY "src/Choices.bbt"
LIBRARY "src/Code.bbt"
LIBRARY "src/Ignore.bbt"
LIBRARY "src/Mem.bbt"
LIBRARY "src/TaskMenu.bbt"

REM These values get replaced by tokenize.

build_version$ = "-.--"
build_date$ = "DD Mmm YYYY"

PROCwimperror_initialise("Float", "!float")
ON ERROR result% = FNwimperror_program : END

PROCinitialise

ON ERROR quit% = FNwimperror_program

WHILE NOT quit%
	PROCpoll
ENDWHILE

PROCclose_down

END


REM Poll the Wimp using Wimp_PollIdle and process the returned reason code.
:
DEF PROCpoll
LOCAL reason%

SYS "Wimp_PollIdle", &3830 + ((NOT display_bubbles%) AND 1), b%, NextPoll% TO reason%

SYS "OS_ReadMonotonicTime" TO NextPoll%
NextPoll% += poll_delay%

CASE reason% OF
	WHEN 0		: PROCidle_event
	WHEN 1		: IF NOT FNignore_process_redraw(b%) THEN PROCredraw_bubble
	WHEN 2		: SYS "Wimp_OpenWindow",, b%
	WHEN 3		: SYS "Wimp_CloseWindow",, b%
	WHEN 6		: PROCmouse_click
	WHEN 8		: SYS "Wimp_ProcessKey", b%!24
	WHEN 9		: PROCmenu_selection
	WHEN 17, 18	: PROCwimp_message
	WHEN 19		: PROCbounced_message
ENDCASE
ENDPROC


REM Handle idle events from the Wimp: monitor the mouse and produce help bubbles
REM as requred.
:
DEF PROCidle_event
LOCAL still_time%, significant_movement%, window_change%, icon_change%
LOCAL key_pressed%, mouse_pressed%, mouse_released%

REM Get the pointer position and set up some variables to idicate the current state.
REM significant_movement% is TRUE if the mouse has moved more than a given amount.
REM window_icon_change% is TRUE if the window or icon under the pointer has changed since the last
REM poll, key_pressed% is TRUE if a key or mouse button has been pressed.

SYS "Wimp_GetPointerInfo",, b%+20

significant_movement% = (ABS(b%!20 - mouse_x%) > mouse_jitter% OR ABS(b%!24 - mouse_y%) > mouse_jitter%)
window_change% = (mouse_window% <> b%!32)
icon_change% = (mouse_icon% <> b%!36)
key_pressed% = FNcode_key_pressed
mouse_pressed% = FNcode_mouse_pressed
mouse_released% = FNcode_mouse_released

IF mouse_pressed% THEN mouse_drag% = TRUE
IF mouse_drag% AND mouse_released% AND NOT significant_movement% THEN mouse_drag% = FALSE

SYS "OS_ReadMonotonicTime" TO current_time%
still_time% = (current_time% - mouse_time%)

REM If there's a bubble open, then we need to decide if it needs to move or
REM or close as a result of events.

IF bubble_open% THEN
	CASE TRUE OF
	WHEN significant_movement%
		PROCclose_bubble
		mouse_x% = b%!20
		mouse_y% = b%!24
	WHEN window_change% OR icon_change%
		PROCclose_bubble
	WHEN (key_pressed% AND hide_on_click%)
		PROCclose_bubble
	WHEN (still_time% > kill_delay% AND kill_bubbles%)
		PROCclose_bubble
	ENDCASE
ENDIF

REM If the window or icon has changed, or there has been "significant" movement
REM of the pointer, update the details and decide whether to open a new bubble.

IF window_change% OR icon_change% OR significant_movement% THEN
	mouse_window% = b%!32
	mouse_icon% = b%!36
	mouse_x% = b%!20
	mouse_y% = b%!24
	SYS "OS_ReadMonotonicTime" TO mouse_time%
	IF NOT (hide_across_drags% AND mouse_drag%) THEN waiting_to_open% = display_bubbles%
ENDIF

REM Detect the end of a mouse drag, after using the drag status.

IF mouse_released% THEN mouse_drag% = FALSE

REM If, after everything else, we're still waiting to open a new bubble, request
REM the details and thereby kick off a new bubble creation process.

IF waiting_to_open% THEN
	IF key_pressed% THEN waiting_to_open% = FALSE
	IF still_time% > bubble_delay% THEN
		waiting_to_open% = FALSE
		PROCget_help_text
	ENDIF
ENDIF
ENDPROC


REM Respond to mouse clicks reported by the Wimp.
:
DEF PROCmouse_click

REM Pass the event details around any code modules that might be interested.

IF FNchoices_process_mouse(b%) THEN ENDPROC
IF FNignore_process_mouse(b%) THEN ENDPROC

REM If we're still here, try to handle the event directly.

CASE b%!12 OF
WHEN -2
	CASE b%!8 OF
	WHEN 4
		PROCset_help_state(NOT display_bubbles%)
	WHEN 2
		PROCmenu_set_state(IconbarMenu%, 3, show_all_help%, FALSE)
		PROCmenu_create_iconbar(IconbarMenu%, !b%)
	WHEN 1
		PROCchoices_open_window(!b%, b%!4)
	ENDCASE

WHEN colours_window%
	IF b%!16 >= 1 THEN PROCchoices_colour_selection(b%!16 - 1)
	PROCwindow_close(colours_window%)

WHEN prog_info_window%
	IF b%!16 = 8 THEN PROCurl_launch(FNmessage_lookup("SupportURL")) : PROCmenu_create(-1,0,0)
ENDCASE
ENDPROC


REM Respond to menu selection events.
:
DEF PROCmenu_selection
LOCAL re_open_menu%, font_name$

REM Check if ADJUST was used to make the selection.

SYS "Wimp_GetPointerInfo",, q%
re_open_menu% = (q%!8 = 1)

REM Act on the menu choice.

CASE FNmenu_current_handle OF
WHEN IconbarMenu%
	CASE !b% OF
	WHEN 1
		OSCLI("%Filer_Run Float:!Help")
	WHEN 2
		PROCchoices_open_window(!q%, q%!4)
	WHEN 3
		show_all_help% = NOT show_all_help%
		PROCmenu_set_state(IconbarMenu%, 3, show_all_help%, FALSE)
	WHEN 4
		quit%=TRUE
	ENDCASE

WHEN FontMenu%
	SYS "Font_DecodeMenu", 0, FontMenu%, b%, q%, 255
	SYS "XOS_GenerateError", q% TO font_name$
	PROCchoices_font_menu_selection(font_name$)

	REM NB. This relies on the fact that FNbuild_font_menu will always return
	REM the same address, as it claims the shared pool from the end of the
	REM WimpSlot. If the value returned could ever change, the Adjust-click
	REM support would break messily.

	PROCdelete_font_menu
	IF re_open_menu% THEN
		FontMenu% = FNbuild_font_menu
	ELSE
		FontMenu% = 0
	ENDIF

WHEN TaskMenu%
	PROCchoices_task_menu_selection(FNtaskmenu_decode(!b%))

	REM NB. Reopening the menu relies on the fact that we do not bother
	REM rebuilding the menu (because there's no tick, and we ignore the
	REM possibility that a task might have started in the meantime). If the
	REM menu were re-built via a call to FNtaskmenu_build, the base address
	REM of the menu could move which would break the Wimp as it would no
	REM longer be seen as the "same" menu.

	IF NOT re_open_menu% THEN
		PROCtaskmenu_delete
		TaskMenu% = 0
	ENDIF
ENDCASE

REM Re-open the menu if ADJUST was used, otherwise inform the menu library that
REM it has closed.

IF re_open_menu% THEN
	PROCmenu_create(FNmenu_current_handle, 0, 0)
ELSE
	PROCmenu_closed
ENDIF
ENDPROC


REM Respond to Wimp message events.
LOCAL task_name$
:
DEF PROCwimp_message
CASE b%!16 OF
WHEN &0
	quit%=TRUE

WHEN &502
	PROCsend_interactive_help

WHEN &503
	IF (NOT FNignore_task(b%!4)) OR show_all_help% THEN PROCexpand_text(b%+20)

WHEN &504
	PROCmessage_help_enable

WHEN &400C1
	PROCnew_mode

WHEN &400C2
	SYS "XOS_GenerateError", b%+28 TO task_name$
	PROCignore_task_starting(b%!4, task_name$)

WHEN &400C3
	PROCignore_task_quitting(b%!4)

WHEN &400C9
	CASE b%!20 OF
	WHEN FontMenu%
		PROCdelete_font_menu
		FontMenu% = 0
	WHEN TaskMenu%
		PROCtaskmenu_delete
		TaskMenu% = 0
	ENDCASE
	PROCmenu_closed

WHEN &400CF
	PROClose_font
	PROCfind_font

WHEN &4E383
	PROCurl_bounce(b%)
ENDCASE
ENDPROC


REM Handle bounced Wimp messages
:
DEF PROCbounced_message
CASE b%!16 OF
WHEN &502
	IF show_default_help% OR show_all_help% THEN PROCmake_default_task_help(icon_bar_help%)

WHEN &4AF80
	PROCurl_bounce(b%)
ENDCASE
ENDPROC


REM ====================================================================================================================
REM Initialisation and termination
REM ====================================================================================================================
:
:
:
:
DEF PROCinitialise
:
REM Initialise the program, including the WIMP.
:
LOCAL os_version%,token_file$,file%,var%,len%,resources_path$,task_name$
:
REM Set up the global data blocks and the parameters needed for WIMP registration.
:
DIM b% 4000, q% 255, a% 255
:
REM Find the correct resources for the current territory.
:
resources_path$=FNresources_find_territory_folder("Float:Resources")
:
REM Allocate space and load the message file into memory.
:
DIM messages% 16
:
SYS "MessageTrans_FileInfo",,resources_path$+"Messages" TO flags%,,size%
REMIF flags% AND 1 THEN buffer%=0 ELSE DIM buffer% size%
DIM buffer% size%
SYS "MessageTrans_OpenFile",messages%,resources_path$+"Messages",buffer%
:
task_name$=FNmessage_lookup("TaskName")
task_sprite$=FNmessage_lookup("TaskSpr")
PROCwimperror_initialise(task_name$,task_sprite$)
wimp_needed%=310
:
REM Choose what messages we accept from the WIMP.
:
!q%=&502     : REM Message_HelpRequest
q%!4=&503    : REM Message_HelpReply
q%!8=&504    : REM Message_HelpEnable
q%!12=&400C1 : REM Message_ModeChange
q%!16=&400C2 : REM Message_TaskInitialise
q%!20=&400C3 : REM Message_TaskCloseDown
q%!24=&400C9 : REM Message_MenusDeleted
q%!28=&400CF : REM Message_FontChanged
q%!32=&4AF80
q%!36=&4E383
q%!40=0      : REM Message_Quit
:
REM Register as a WIMP task.
:
SYS "Wimp_Initialise", wimp_needed%, &4B534154, task_name$, q% TO TaskHandle%
:
REM Set the quit flag to false so we don't quit immediately.  Get the current time ready for
REM calling Wimp_PollIdle - this will cause the first null poll to be returned immediately.
:
quit%=FALSE
SYS "OS_ReadMonotonicTime" TO NextPoll%
:
REM Initialise the WimpSlot
:
PROCmem_initialise
:
REM Load the correct set of message tokens for the version of RISC OS we are running on at the
REM moment.
:
REM Load a suitable file of message tokens.  First try in ROM, then in !Boot, then look in our own collection
REM of versions and finally fall back onto the RISC OS 3.1 data (Tokens.164).
:
token_file$="Resources:$.Resources.Help.Messages"
SYS "OS_File",17,token_file$ TO file%
IF file%=0 THEN
 SYS "XOS_ReadVarVal","BootResources$Path",0,-1,0,0 TO ,,var%
 IF var%<0 THEN
  token_file$="BootResources:!Help.Messages"
  SYS "OS_File",17,token_file$ TO file%
 ENDIF
ENDIF
IF file%=0 THEN
 SYS "OS_Byte",129,0,&FF TO ,os_version%
 token_file$=resources_path$+"Tokens."+FNresources_find_latest_object(resources_path$+"Tokens","",os_version%)
 SYS "OS_File",17,token_file$ TO file%
ENDIF
IF file%=0 THEN token_file$=resources_path$+"Tokens.164"
:
SYS "MessageTrans_FileInfo",,token_file$ TO flags%,,size%
IF flags% AND 1 THEN token_buffer%=0 ELSE DIM token_buffer% size%
SYS "OS_Module",6,,,17+LEN(token_file$) TO ,,tokens%
$(tokens%+16)=token_file$
SYS "MessageTrans_OpenFile",tokens%,tokens%+16,token_buffer%
:
REM Allocate space for the indirected icon data and load the templaes file into memory, creating the
REM windows as we go.
:
ind_size%=3000
DIM ind_area% ind_size%
:
PROCtemplate_open(resources_path$+"Templates")
:
PROCchoices_initialise
PROCignore_initialise
PROCtaskmenu_initialise
:
PROCtemplate_load("Panel",b%,ind_area%,ind_size%,-1)
SYS "Wimp_CreateWindow",,b% TO bubble_window%
PROCtemplate_load("ProgInfo",b%,ind_area%,ind_size%,-1)
SYS "Wimp_CreateWindow",,b% TO prog_info_window%
PROCtemplate_load("Colours",b%,ind_area%,ind_size%,-1)
SYS "Wimp_CreateWindow",,b% TO colours_window%
:
PROCtemplate_close
:
$FNicon_indirection(prog_info_window%,4)=CHR$(169) + " Stephen Fryatt, 1999-" + MID$(build_date$, 8)
$FNicon_indirection(prog_info_window%,6)=build_version$+" ("+build_date$+")"
:
REM Load the sprites file into memory.
:
sprite_area%=FNwimpsprite_load_user_sprites("Float:Sprites")
:
REM Load the menu definitions into memory and create the menus.
:
PROCmenu_initialise
!q%=prog_info_window%
PROCmenu_load_templates(resources_path$+"Menus",q%)
IconbarMenu% = !q%
FontMenu% = 0
TaskMenu% = 0
:
REM Set up all the global variables
:
mouse_x%=0            : REM The last known mouse X position
mouse_y%=0            : REM The last known mouse Y position
mouse_time%=0         : REM When the mouse was last known to be 'still'
mouse_window%=0       : REM The last window the mouse was over
mouse_icon%=0         : REM The last icon the mouse was over
mouse_drag%=FALSE     : REM TRUE is the mouse is thought to be dragging
bubble_open%=FALSE    : REM TRUE if a bubble is open
waiting_to_open%=TRUE : REM TRUE if a bubble is still waiting to be opened
bubble_width%=0       : REM The width (in OS units) of the current bubble
bubble_height%=0      : REM The height (in OS units) of the current bubble
bubble_lines%=0       : REM The number of lines of text in the current bubble
show_all_help%=FALSE  : REM TRUE if we are to ignore the selective help settings in Choices.
:
REM Allocate arrays and memory blocks.
:
help_text_size%=4095              : REM The size of the help text buffer
DIM help_text% help_text_size%
DIM font_block% 35
max_lines%=1000                   : REM The maximum number of lines of text in a bubble
DIM start%(max_lines%),length%(max_lines%),y_offset%(max_lines%)
:
REM Determine if the desktop font exists.
:
SYS "XWimp_ReadSysInfo",8 TO ;flags%
desktop_font_available%=((flags% AND 1)=0)
:
REM Set up the default configuration and load any changes
:
PROCconfig_initialise(20,task_name$)
:
PROCconfig_init_boolean("Open bubbles",TRUE)
PROCconfig_init_boolean("Close bubbles",TRUE)
PROCconfig_init_boolean("Draw shadows",TRUE)
PROCconfig_init_boolean("Hide over drags",TRUE)
PROCconfig_init_boolean("Hide on clicks",TRUE)
PROCconfig_init_boolean("Show tool help", TRUE)
PROCconfig_init_boolean("Show bar help", TRUE)
PROCconfig_init_boolean("Identify silent apps", FALSE)
PROCconfig_init_real("Open delay",0.6)
PROCconfig_init_real("Close delay",10)
PROCconfig_init_integer("Foreground colour",7)
PROCconfig_init_integer("Background colour",1)
PROCconfig_init_integer("Shadow colour",6)
PROCconfig_init_string("Font name","Homerton.Bold.Oblique")
PROCconfig_init_real("Font size",10)
PROCconfig_init_real("Font aspect",100)
PROCconfig_init_boolean("Font use desktop",FALSE)
PROCconfig_init_integer("Mouse jitter",8)
PROCconfig_init_integer("Poll delay",5)
PROCconfig_init_string("Ignore tasks","")
:
:
choices_load$="Choices:Float.Choices"
SYS "XOS_File",17,choices_load$ TO choices_type% ;flags%
IF (flags% AND 1)<>0 OR choices_type%<>1 THEN choices_load$="Float:Choices"
choices_save$=FNconfig_load_file(choices_load$)
:
REM Create all the config variables used in the program.
:
PROCchoices_sync
:
REM Set up the list of tasks to ignore.
:
PROCignore_load_tasks
:
REM Find the font we need to display the text and get the size of the screen mode.
:
SYS "Font_CacheAddr" TO font_manager_version%
PROCfind_font
PROCget_mode_size
:
REM Put an icon on the icon bar.
:
DIM bar_sprite% 10
IF display_bubbles% THEN $bar_sprite%="on" ELSE $bar_sprite%="off"
:
!q%=-1
q%!4=0
q%!8=0
q%!12=68
q%!16=68
q%!20=&311A
q%!24=bar_sprite%
q%!28=sprite_area%
q%!32=10
SYS "Wimp_CreateIcon",,q% TO bar_icon_handle%
:
PROCcode_initialise
ENDPROC
:
:
:
:
REM --------------------------------------------------------------------------------------------------------------------
:
:
:
:
DEF PROCclose_down
:
REM Close the task down, losing the font and closing the messages file first.
:
PROCcode_finalise
PROClose_font
SYS "MessageTrans_CloseFile", messages%
SYS "MessageTrans_CloseFile", tokens%
SYS "Wimp_CloseDown", TaskHandle%, &4B534154
ENDPROC
:
:
:
:
REM ====================================================================================================================
REM Interactive help (for our own windows and icons)
REM ====================================================================================================================
:
:
:
:

REM Supply interactive help messages for ourselves to any interactive help
REM client which requests them. 
:
DEF PROCsend_interactive_help
LOCAL processed%, token$, len%

REM Try and find an appropriate token for the window and icon currently under
REM the pointer.

processed% = FALSE
token$=""

REM First pass the message to any modules which might have an interest, stopping
REM as soon as one claims the message.

IF NOT processed% THEN processed% = FNchoices_process_help_request(b%, token$)

REM If none of the modules claimed the message, have a go at finding a suitable
REM token for the remaining windows.

IF NOT processed% THEN
	CASE b%!32 OF
	WHEN -2
		token$ = "HelpH1"

	WHEN prog_info_window%
		IF b%!36 = 8 THEN token$ = "HelpH5" ELSE token$ = "HelpH4"

	WHEN colours_window%
		IF b%!36 > 0 THEN token$ = "HelpCC1" ELSE token$ = "HelpCC0"

	WHEN bubble_window%
		REM Don't return help on the bubble itself...

	OTHERWISE
		SYS "Wimp_GetMenuState", 1, q%, b%!32, b%!36
		CASE FNmenu_current_handle OF
		WHEN IconbarMenu%
			IF !q% > -1 THEN token$ = "Menu0" + STR$(!q% + 1)
		WHEN FontMenu%
			IF !q% > -1 THEN token$ = "MenuFF"
		WHEN TaskMenu%
			IF !q% > -1 THEN token$ = "MenuTT"
		ENDCASE
	ENDCASE
ENDIF

REM If a token was found, look it up and reply to the help request.

IF token$ <> "" THEN
	SYS "MessageTrans_Lookup", messages%, token$, b%+20, 235 TO ,,,len%

	b%!12 = b%!8
	b%!16 = &503
	!b% = 24 + (len% AND &FFFFFC)
	SYS "Wimp_SendMessage", 17, b%, b%!4
ENDIF
ENDPROC
:
:
:
:
REM ====================================================================================================================
REM Help text processing and display
REM ====================================================================================================================
:
:
:
:
DEF PROCget_help_text
:
REM Get the help text for the bubble.
REM
REM This procedure relies on Wimp_GetPointerInfo having been called already with a data block of
REM b%+20 so it should only be called from the idle poll handler.  If the icon is greater than or
REM equal to -1, the application owning the object being pointed to must be sent a
REM Message_HelpRequest.  If the icon is less than -1, it is a bit of window furniture and
REM PROCexpand_text can be called immediately with the result from looking up the correct text in
REM the message file.
:
IF b%!32>-2 OR show_ibar_help% OR show_all_help% THEN
 IF b%!36>=-1 THEN
  b%!0=40
  b%!12=0
  b%!16=&502
  icon_bar_help%=(b%!32=-2) AND (b%!36<>-1)
  SYS "Wimp_SendMessage",18,b%,b%!32,b%!36 TO ,,helped_task_handle%
 ELSE
  IF show_tool_help% OR show_all_help% THEN
   SYS "MessageTrans_Lookup",messages%,"HelpI"+STR$(-(b%!36)),b%,40000
   PROCexpand_text(b%)
  ENDIF
 ENDIF
ENDIF
ENDPROC
:
:
:
:
REM --------------------------------------------------------------------------------------------------------------------
:
:
:
:
DEF PROCmake_default_task_help(icon_bar%)
:
REM A task has not responded to a request.  If it was us, just ignore it.
REM
REM Using the task handle we recorded in PROCget_help_text the task name is looked up and inserted
REM into the default piece of text from our messages file before passing this to PROCexpand_text.
REM Token HelpH2 is used for icon-bar icons, HelpH3 is used for windows.
:
LOCAL task_name%,token$,flags%
:
IF helped_task_handle%<>TaskHandle% THEN
 IF icon_bar% THEN token$="2" ELSE token$="3"
 :
 SYS "XTaskManager_TaskNameFromHandle",helped_task_handle% TO task_name% ;flags%
 :
 IF (flags% AND 1) =0 THEN
  SYS "MessageTrans_Lookup",messages%,"HelpH"+token$,b%,4000,task_name%
  PROCexpand_text(b%)
 ENDIF
ENDIF
ENDPROC
:
:
:
:
REM --------------------------------------------------------------------------------------------------------------------
:
:
:
:
DEF PROCexpand_text(original_text%)
:
REM Expand the text and open the bubble on the screen if help text has been received.
REM
REM The text must be 'escaped' to remove the \X compressions used by Acorn (including the extras
REM used in RISC OS 3.5+), GSTrans'd and finally formatted.
:
LOCAL o%, h%, c%, len%
:
REM Start by 'escaping' the string, by expanding with the dictionary in the Messages file.
REM
REM For each craracter in the (control terminated) string, if it is NOT a '\' copy it straight
REM in to the help_text% buffer and step on one.  If it is a '\', get the next charater and
REM step on one more.  If the next character is a '\' as well, copy one '\' into the help_text%
REM buffer and move on one character.
REM
REM If the second character was NOT a '\', append it to a 'T' and look up the resulting token in
REM the Messages file dictionary.  The call is asked to put the result straight into the
REM help_text% buffer in the correct place, before the buffer pointer is moved on by the length
REM of the result.
:
o%=0
h%=0
:
REPEAT
 c%=original_text%?o%
 o%+=1
 :
 IF CHR$(c%)<>"\" THEN
  IF (INSTR("€„ˆ‰Š‹",CHR$(c%))>0) AND (symbol_font%>0) THEN
   help_text%?h%=26
   help_text%?(h%+1)=symbol_font%
   help_text%?(h%+2)=c%
   help_text%?(h%+3)=26
   help_text%?(h%+4)=display_font%
   h%+=5
  ELSE
   help_text%?h%=c%
   h%+=1
  ENDIF
 ELSE
  c%=original_text%?o%
  o%+=1
  :
  IF CHR$(c%)="\" THEN
   help_text%?h%=ASC("\")
   h%+=1
  ELSE
   SYS "XMessageTrans_Lookup",tokens%,"T"+CHR$(c%),help_text%+h%,help_text_size%-h% TO ,,,len%
   h%+=len%
  ENDIF
 ENDIF
UNTIL c%<32 OR h%>=help_text_size%
:
REM If the expansion ended bacause the buffer was full, terminate with a message that makes this
REM clear.
:
IF h%>=help_text_size% THEN
 $(help_text%+help_text_size%-27)="...|M[help text truncated]" : help_text%?(help_text_size%-1)=0
ELSE
 help_text%?(h%-1)=0
ENDIF
:
REM Open the bubble on the screen with the string in the help_text% buffer.  This will need to be
REM GSTrans'd and formatted first.
:
PROCopen_bubble(help_text%)
ENDPROC
:
:
:
:
REM --------------------------------------------------------------------------------------------------------------------
:
:
:
:
DEF PROCopen_bubble(text%)
:
REM Given a pointer to a string needing to be GSTrans'd, do this and then open a bubble.
:
LOCAL line%,lines%,t%,widest%,y_offset%,actual_lines%,max_width%,width%,end%,length%,line_height%
LOCAL r%,w%,double_end%,os_width%,os_height%,icon_bar_height%,x_pos%,y_pos%,shadow_size%
:
REM The control terminated string is passed through a GSTrans function to 'un-escape' the '|'
REM characters in it.  '|M' is treated specially, as it must be converted into string terminators
REM for the Font_ScanString routine to cope with; these are replaced with two zero bytes as
REM terminators.  The number of lines counted is recorded from zero in lines%.
REM
REM r% is the read pointer, w% is the write pointer.  If the character read is not '|', it is
REM copied to the write pointer and both r% and w% are incremented.  If it is '|', the r% is
REM incremented and the following character is read.  If it is '|', '<' OR '"' this is copied to
REM w% and both r% and w% are incremented.  If it is 'M' (that is '|M'), then a check is made
REM to see if the last character written was a zero.  If it is, we must have just passed a
REM '|M|M' sequence (or null string) and double_end% is set to terminate the parsing; if not
REM a zero line separator is written, lines% is incremented and both r% and w% are incremented.
REM
REM All this complexity is needed as !Help teats '|M|M' as a terminator and misses apparent garbage
REM that !Zap throws at it after the '|M|M'?
:
r%=0
w%=0
lines%=0
double_end%=FALSE
:
REM Test for <>0 so as to allow font-change control chars through.
:
WHILE text%?r%<>0 AND NOT double_end%
 IF CHR$(text%?r%)="|" THEN
  r%+=1
  IF CHR$(text%?r% AND &DF)="M" THEN
   IF text%?(w%-1)<>0 THEN lines%+=1 : text%?w%=0 : w%+=1 ELSE double_end%=TRUE
  ELSE
   CASE CHR$(text%?r%) OF
    WHEN "|"  : text%?w%=ASC("|")  : w%+=1
    WHEN "<"  : text%?w%=ASC("<")  : w%+=1
    WHEN """" : text%?w%=ASC("""") : w%+=1
   ENDCASE
  ENDIF
 ELSE
  text%?w%=text%?r%
  w%+=1
 ENDIF
 :
 r%+=1
ENDWHILE
:
IF text%?(w%-1)=0 THEN lines%-=1
:
REM Add a terminator for those who do not end the help string with '|M'.
:
text%?w%=0
:
REM Set up the co-ordinates block as required by Font_ScanString.  font_block%!16 is a space for the
REM possible split character.
:
font_block%!0=0
font_block%!4=0
font_block%!8=0
font_block%!12=0
font_block%!16=32
:
REM Calculate the widest the bubble can be.
REM
REM **** Currently we just assume that it is 600 OS units; this should depend on many factors,
REM **** such as screen width.
:
SYS "Font_Converttopoints",,600 TO ,widest%
:
REM The string is now scanned with Font_ScanString to break it up into lines and prepare for
REM printing.  t% is made a temporary pointer for the text buffer, y_offset% is the current line
REM offset from the first in millipoints, actual_lines% is the number of lines to be printed,
REM max_width% is the maximum line width in millipoints and line_height% is the millipoint line
REM spacing, calculated on a fixed 120% from the font size in 16ths of a point.
:
t%=text%
y_offset%=0
actual_lines%=0
max_width%=0
SYS "Font_ReadDefn",display_font%,q% TO ,,,line_height%
line_height%=(line_height%*1000)/16*1.2
:
REM For each line found above, Font_ScanString is repeatedly called to find the line lengths that
REM will fit into the specified limit widest% in millipoints.  For each call, as long as the
REM maximum number of lines has not been exceeded the start point in the string, number of
REM characters and y offset are stored away for future use.  If the line is found to be the
REM widest so far, its width is also remembered.
REM
REM widest% is slowly increased in the event of long lines occurring.  This prevent truncation
REM and the window will grow approporiately.  If the line was zero long it is not added to the
REM list of lines found.
REM
REM **** This should check the mode width and maybe re-scan the text above as width is increased.
REM
REM The t% pointer is moved on the length of the string found by Font_ScanString and if the
REM next character is a space t% is advanced one more.  If the length of the line was non-zero
REM the offset is advanced by one line for the line spacing.
REM
REM The repeat loop is stopped when a termination control character is found.  If the last line
REM was non-zero length, a paragraph space of 1/3 line spacing is added and t% advanced across the
REM spacing zero bytes before the rest of the lines identified above are scanned in the same way.
:
FOR line%=0 TO lines%
 REPEAT
  REPEAT
   SYS "Font_ScanString",display_font%,t%,&00320,widest%,0,font_block% TO ,end%,,width%
   length%=end%-t%
   IF length%=0 THEN widest%+=500
  UNTIL length%>0 OR ?t%=0 OR ?t%=13
  :
  IF actual_lines%<=max_lines% AND length%>0 THEN
   start%(actual_lines%)=t%
   length%(actual_lines%)=length%
   y_offset%(actual_lines%)=y_offset%
   actual_lines%+=1
   IF width%>max_width% THEN max_width%=width%
  ENDIF
  :
  t%+=length%
  IF ?end%=32 THEN t%+=1
  :
  IF length%>0 THEN y_offset%+=line_height%
 UNTIL ?t%=0 OR actual_lines%>max_lines%
 :
 IF length%>0 THEN y_offset%+=line_height%/3
 :
 WHILE ?t%=0
  t%+=1
 ENDWHILE
NEXT line%
:
REM Put the bubble onto the screen, if there are any lines of text to display.
REM
REM First get details of the pointer position so that we know where to open the help bubble and can
REM check if the pointer is in the icon bar (for special positioning).
REM
REM The bubble width (max_width%) and height (y_offset%) are converted into OS units and 16 OS units
REM are added to allow some margins.  If the pointer is NOT over the icon bar, the bubble is
REM positioned under the pointer if there is room, or above it otherwise (remember y_pos% is the
REM top of the bubble).  If the pointer is over the icon bar, the bubble is positioned at the top
REM of the bar (fixed height).
REM
REM The x position is set to be the pointer position (x_pos% is the left of the bubble).  It can be
REM a minimum of 50 OS units from a screen edge, so it is then moved in if required.
:
IF actual_lines% THEN
 SYS "Wimp_GetPointerInfo",,q%
 :
 SYS "Font_ConverttoOS",,max_width%,y_offset% TO ,os_width%,os_height%
 os_width%+=16
 :
 icon_bar_height%=132
 :
 IF q%!12<>-2 THEN
  IF (q%!4)-32-os_height%<icon_bar_height% THEN y_pos%=q%!4+os_height%+20 ELSE y_pos%=q%!4-48
 ELSE
  y_pos%=icon_bar_height%+os_height%
 ENDIF
 :
 x_pos%=!q%
 IF x_pos%<50 THEN x_pos%=50
 IF x_pos%+os_width%>screen_width%-50 THEN x_pos%=screen_width%-50-os_width%
 :
 REM x_pos% and y_pos% are converted into millipoints for the Font_Paint command, with an 8 OS unit
 REM margin added on the left.  The font start point is moved down a line as fonts paint from the
 REM baseline up.  The size of the shadow is calculated (zero if there is no shadow).
 REM
 REM The bubble window is opened at the correct point to accommodate the panel and its shadow.  The
 REM vales needed by the redraw code are stored and the bubble is marked open.
 :
 shadow_size%=draw_shadow%*-8
 :
 IF bubble_open% THEN PROCwindow_close(bubble_window%)
 :
 !q%=bubble_window%
 q%!4=x_pos%
 q%!8=y_pos%-os_height%-shadow_size%
 q%!12=x_pos%+os_width%+shadow_size%+2
 q%!16=y_pos%+4
 q%!20=0
 q%!24=0
 q%!28=-1
 SYS "Wimp_OpenWindow",,q%
 :
 bubble_width%=os_width%
 bubble_height%=os_height%
 bubble_lines%=actual_lines%
 :
 IF bubble_open% THEN PROCwindow_force_redraw(bubble_window%)
 bubble_open%=TRUE
ENDIF
ENDPROC
:
:
:
:
REM --------------------------------------------------------------------------------------------------------------------
:
:
:
:
DEF PROCredraw_bubble
:
REM Redraw the bubble window.
REM
REM The redraw loop is not optimised as bubbles are supposed to be on top and so the window should
REM always be redrawn in one go.  In fact, the only real reason for a redraw is if F12, Return is
REM pressed when a bubble is open (and then the transparent parts of the window will be wrong).
:
LOCAL shadow_size%,line_height%,x%,y%,x_in%,y_in%,more%,line%
:
REM Calculate the size of the shadow and the line height in points (120% of fint size).
:
shadow_size%=draw_shadow%*-8
line_height%=(font_size%*1000)/16*1.2
:
REM Go into the WIMP redraw loop.
:
SYS "Wimp_RedrawWindow",,b% TO more%
:
WHILE more%
 :
 REM Calculate the position of the top left of the bubble window, converting this to millipoints
 REM and pointing to the bottom of the first line of text (fonts are painted from the baseline)
 :
 x%=b%!4-b%!20
 y%=b%!16-b%!24-4
 :
 SYS "Font_Converttopoints",,x%+8,y% TO ,x_in%,y_in%
 y_in%-=line_height%
 :
 REM If there is to be a shadow, drwa it.  Then draw the box as a filled rectangle overlaid by
 REM an open rectangle.
 :
 IF draw_shadow% THEN
  SYS "Wimp_SetColour",shadow_colour%
  RECTANGLE FILL x%+shadow_size%,y%-bubble_height%-shadow_size%,bubble_width%,bubble_height%
 ENDIF
 :
 SYS "Wimp_SetColour",background_colour%
 RECTANGLE FILL x%,y%-bubble_height%,bubble_width%,bubble_height%
 SYS "Wimp_SetColour",text_colour%
 RECTANGLE x%,y%-bubble_height%,bubble_width%,bubble_height%
 :
 REM Set the font colours and plot the text line by line.
 :
 SYS "Wimp_SetFontColours",,background_colour%,text_colour%
 :
 FOR line%=0 TO bubble_lines%-1
  SYS "Font_Paint",display_font%,start%(line%),&380,x_in%,y_in%-y_offset%(line%),,,length%(line%)
 NEXT line%
 :
 SYS "Wimp_GetRectangle",,b% TO more%
ENDWHILE
ENDPROC
:
:
:
:
REM --------------------------------------------------------------------------------------------------------------------
:
:
:
:
DEF PROCclose_bubble
:
REM Close the help bubble.
REM
REM Close the backing window so the WIMP redraws the screen, then flag the bubble closed.
:
IF bubble_open% THEN PROCwindow_close(bubble_window%)
bubble_open%=FALSE
ENDPROC
:
:
:
:
REM ====================================================================================================================
REM Misc Wimp message handlers
REM ====================================================================================================================
:
:
:
:
DEF PROCset_help_state(new_state%)
:
REM Set whether bubbles are being opened and update the icon-bar icon appropriately.
REM
REM Mainly used by clicks on the icon bar, but also by closing the config window.
:
display_bubbles%=new_state%
:
IF display_bubbles% THEN
 $bar_sprite%="on"
ELSE
 $bar_sprite%="off"
 PROCclose_bubble
ENDIF
PROCicon_redraw(-2,bar_icon_handle%)
ENDPROC
:
:
:
:
REM --------------------------------------------------------------------------------------------------------------------
:
:
:
:
DEF PROCmessage_help_enable
:
REM Handle Message_HelpEnable (set the help state and reload the choices if required to).
:
PROCset_help_state((b%!20 AND 1)=0)
IF (b%!20 AND 2)=2 THEN
 PROCconfig_load_file("Float:Choices")
 PROCchoices_sync
ENDIF
:
ENDPROC
:
:
:
:
REM --------------------------------------------------------------------------------------------------------------------
:
:
:
:
DEF PROCnew_mode
:
REM In the event of a mode change, re-bind the font handle and get the new mode size.
:
LOCAL font_width%
:
font_width%=FNconfig_read_real("Font aspect")*font_size%/100
PROClose_font
PROCfind_font
REMSYS "Font_LoseFont",display_font%
REMSYS "XFont_FindFont",,FNconfig_read_string("Font name"),font_width%,font_size%,0,0 TO display_font% ;flags%
REMIF (flags% AND 1) THEN SYS "Font_FindFont",,"Trinity.Medium",font_aspect%*font_size%/100,font_size%,0,0 TO display_font%
PROCget_mode_size
ENDPROC
:
:
:
:
REM --------------------------------------------------------------------------------------------------------------------
:
:
:
:
DEF PROCget_mode_size
:
REM Set the variables screen_width% and screen_height% to be the width and height of the current
REM mode (in OS units), derived from the relevent Mode Variables.
:
LOCAL m%,n%
:
SYS "OS_ReadModeVariable",-1,11 TO ,,m%
SYS "OS_ReadModeVariable",-1,4  TO ,,n%
screen_width%=m%<<n%
:
SYS "OS_ReadModeVariable",-1,12 TO ,,m%
SYS "OS_ReadModeVariable",-1,5  TO ,,n%
screen_height%=m%<<n%
ENDPROC
:
:
:
:
REM ====================================================================================================================
REM Font management
REM ====================================================================================================================
:
:
:
:
DEF FNbuild_font_menu
:
LOCAL menu_buf%,ind_buf%,menu_buf_size%,ind_buf_size%,fonts_message_file$,mess_buf%,menu_title%
:
SYS "Font_ListFonts",,0,(1<<19),,0,,0 TO ,,,menu_buf_size%,,ind_buf_size%

menu_buf% = FNmem_claim(menu_buf_size% + ind_buf_size%)

IF menu_buf% <> 0 THEN
 ind_buf% = menu_buf% + menu_buf_size%
 SYS "Font_ListFonts",,menu_buf%, &280000, menu_buf_size%, ind_buf%, ind_buf_size%, FNchoices_font_menu_selected
 :
 IF font_manager_version%<=307 THEN
  fonts_message_file$="Resources:$.Resources.Fonts.Messages"
  SYS "OS_Module",6,,,17+LEN(fonts_message_file$) TO ,,mess_buf%
  $(mess_buf%+16)=fonts_message_file$
  SYS "MessageTrans_OpenFile",mess_buf%,mess_buf%+16,0
  SYS "MessageTrans_Lookup",mess_buf%,"FontList",0 TO ,,menu_title%
  IF LEN(FNstring_read(menu_title%))>12 THEN
   menu_buf%!28=menu_buf%!28 OR &10
  ELSE
   menu_buf%!28=menu_buf%!28 AND &FFFFFFEF
  ENDIF
  SYS "MessageTrans_CloseFile",mess_buf%
  SYS "OS_Module",7,,mess_buf%
 ENDIF
ELSE
 menu_buf%=0
ENDIF
:
=menu_buf%
:
:
:
:
REM --------------------------------------------------------------------------------------------------------------------
:
:
:
:
DEF PROCdelete_font_menu
PROCmem_release
ENDPROC
:
:
:
:
REM --------------------------------------------------------------------------------------------------------------------
:
:
:
:
DEF PROCfind_font
:
using_desktop_font%=FALSE
:
IF desktop_font_available% AND font_desktop% THEN
 SYS "Wimp_ReadSysInfo",8 TO display_font%,symbol_font%
 using_desktop_font%=(display_font%<>0)
ENDIF
:
IF NOT using_desktop_font% THEN
 SYS "XFont_FindFont",,font_name$,font_aspect%*font_size%/100,font_size%,0,0 TO display_font% ;flags%
 IF (flags% AND 1) THEN SYS "Font_FindFont",,"Trinity.Medium",font_aspect%*font_size%/100,font_size%,0,0 TO display_font%
 SYS "XFont_FindFont",,"WIMPSymbol",font_aspect%*font_size%/100,font_size%,0,0 TO symbol_font% ;flags%
 IF (flags% AND 1) THEN symbol_font%=0
ENDIF
ENDPROC
:
:
:
:
REM --------------------------------------------------------------------------------------------------------------------
:
:
:
:
DEF PROClose_font
:
IF NOT using_desktop_font% THEN SYS "Font_LoseFont",display_font% : SYS "Font_LoseFont",symbol_font%
ENDPROC
:
:
:
:
REM ====================================================================================================================
REM Misc routines
REM ====================================================================================================================
:
:
:
:
DEF PROCset_colour_icon(w%,i%,c%)
:
REM Set the given icon's bacground to the correct colour and change the text to show the colour
REM number.
:
LOCAL f%
:
IF c%>=4 AND c%<=8 THEN f%=0 ELSE f%=7
PROCicon_set_colours(w%,i%,f%,c%)
$FNicon_indirection(w%,i%)=STR$(c%)
ENDPROC
:
:
:
:
REM --------------------------------------------------------------------------------------------------------------------
:
:
:
:
DEF FNmessage_lookup(token$)
:
REM Look up a token in the messages file, returning the associated message text.
:
LOCAL message$
:
IF token$<>"" THEN SYS "MessageTrans_Lookup",messages%,token$,0 TO ,,message$ ELSE message$=token$
=message$
